clear
%% This code calculates the alongshore velocity generated by local winds
%% based on a barotropic response, frictionally adjusted flow (Whitney and
%% Garvine, 2005)

% Load wind speed data
load /Users/dever_mathieu/Documents/PhD/data/PART_I/Wind_Index/HFX_glider/Uwind/ECMWF_NSC_20112014.mat

% The idea is to:
%           1- Create a line with a 0.01° longitudinal resolution between
%           Devils Island (-63.4572;44.5824) and HL4 (-62.448;43.481)
%
%           2- Find the closest grid point for each point along this line
%           to determine the grid points that should be average to use a
%           wind conditions.
%
%           3- Applies a 3-day filter to account for the adjustement-time
%           of the frontal parameters to wind.

% 1- Finds the gridpoints located along the HL
start = [-63.4572,44.5824];
finish = [-62.0755,43];
HL_lon = start(1):0.01:finish(1);
HL_lat = interp1([start(1) finish(1)], [start(2) finish(2)],HL_lon);
clear start finish

% Find the closest grid point
[X,Y] = meshgrid(lon,lat);
counter = 1;
for ii = 1 :length(HL_lon)
    % Calculate the distance from the HL
    dist_temp = GPS2dist(HL_lon(ii),HL_lat(ii),X,Y);
    % Find the minimum
    [r(ii),c(ii)] = find(dist_temp == min(min(abs(dist_temp))));
    
    if ii == 1 || r(ii)~=r(ii-1) || c(ii)~=c(ii-1)
        % record the index of the closest cell
        wind_cell_index(1,counter) = c(ii);
        wind_cell_index(2,counter) = r(ii);
        counter = counter +1;
    end
    
    clear dist_temp
end; clear ii r c counter X Y
clear HL_*

HL.lon = lon(wind_cell_index(1,:));
HL.lat = lat(wind_cell_index(2,:));

% extract the average of cells of interest from the complete matrix.
for ii = 1:size(wind_cell_index,2)
    HL.U(ii,:) = U(wind_cell_index(1,ii),wind_cell_index(2,ii),:);
    HL.V(ii,:) = V(wind_cell_index(1,ii),wind_cell_index(2,ii),:);
end; clear ii
clear wind_cell_index
HL.U = squeeze(nanmean(HL.U,1));
HL.V = squeeze(nanmean(HL.V,1));

HL.U = bwfilter(HL.U,72,[],1/(6*60*60));
HL.V = bwfilter(HL.V,72,[],1/(6*60*60));

HL.time = time;

[HL.xshore, HL.ashore] = rotation(HL.U,HL.V,[],'location','HFX');

% Average the wind time series daily
[HL.U_day,HL.time_day] = time_average(HL.U',datevec(time),'day',1);
[HL.V_day,HL.time_day] = time_average(HL.V',datevec(time),'day',1);
HL.time_day = datenum(HL.time_day);

% Convert to ashore,xshore components
[HL.xshore_day, HL.ashore_day] = rotation(HL.U_day,HL.V_day,[],'location','HFX');

% Filters the time series
% Coeficients necessary to the calculation of Uwind
coef.Cds = 1.2e-3/2;
coef.Cdb = 5e-3;
coef.Cdba = (8+(1/sqrt(coef.Cdb)))^-2;
coef.rho_air = 1.2;
coef.rho = 1027;

%sqrt((rho_air*Cds)/(rho*Cdba));
U_wind = sqrt((coef.rho_air*coef.Cds)/(coef.rho*coef.Cdba)).*HL.ashore_day;

figure('units','normalized','outerposition',[0 0 1 1])
plot(HL.time_day,U_wind,'k');
xlim([datenum([2012 1 1 0 0 0]) datenum([2014 12 31 0 0 0])])
datetick('x','mmmyy','keeplimits'); grid on; hold on
ylabel('U_w_i_n_d (m/s)')
%plot(HL.time_day,smooth(U_wind,5),'-r','linewidth',2);
line([HL.time_day(1) HL.time_day(end)],[0 0]);
%legend('daily U_w_i_n_d','5-day moving average');
set(gca,'fontsize',14)

set(gcf,'color','w')
export_fig Uwind_plot.png
save('U_wind.mat','coef','U_wind','HL')

clear
%% Extract U_wind for each calculated U_dis
dis = load('/Users/dever_mathieu/Documents/PhD/data/PART_I/Wind_Index/HFX_glider/Udis/frontal_dimensions.mat');

load('U_wind.mat')
U_wind_TS = U_wind;clear U_wind
% Match the two time series
for tt = 1:length(dis.U_dis)
    [~,start] = min(abs(HL.time_day-dis.HL.start_time(tt)));
    [~,finish] = min(abs(HL.time_day-dis.HL.finish_time(tt)));
    
    U_wind(tt) = nanmean(U_wind_TS(start:finish));
end; clear tt start finish
clear dis
save('U_wind.mat')
